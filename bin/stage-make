#!/usr/bin/env bash
source "$(dirname "$0")/common/bootstrap.sh"
STAGE_NAME=$1;
TARGET_NAME=$2;
TARGET_DIRECTORY="${SERVER_STAGE_DIRECTORY}/$STAGE_NAME/current"
LOGS_DIRECTORY="${SERVER_STAGE_DIRECTORY}/$STAGE_NAME/logs"
LOG_FILE=${LOGS_DIRECTORY}/${TARGET_NAME}.log;

if [ ! -d ${TARGET_DIRECTORY} ]; then
    printf "\nERROR: DIRECTORY [${TARGET_DIRECTORY}] not found!\n";
    exit 1;
fi

if [ ! -d ${LOGS_DIRECTORY} ]; then
    mkdir -p ${LOGS_DIRECTORY};
fi

if [ ! -d ${HTTPS_GATEWAY_VAR_DIRECTORY} ]; then
   mkdir -p $HTTPS_GATEWAY_VAR_DIRECTORY;
fi

cd ${TARGET_DIRECTORY};

LOCKFILE="${HTTPS_GATEWAY_VAR_DIRECTORY}/locker${TARGET_DIRECTORY//\//-}-${TARGET_NAME/@/_}.lock";
LOCKFD=99

_lock()             { flock -$1 "$LOCKFD"; }
_no_more_locking()  { _lock u; _lock xn && rm -f $LOCKFILE; }
_prepare_locking()  { eval "exec $LOCKFD>\"$LOCKFILE\""; trap _no_more_locking EXIT; }
_throw_exit()       { printf "\n ERROR => Locker FOUND:\n$LOCKFILE\n[EXIT]\n"; exit 1; }
exlock_now()        { _lock xn; }  # obtain an exclusive lock immediately or fail

_timestamp() {
  date "+%Y-%m-%d %H:%M:%S";
}
# ON START
_prepare_locking

# Simplest example is avoiding running multiple instances of script.
exlock_now || _throw_exit;

printf "\n$(_timestamp) [stage-make][$STAGE_NAME::$TARGET_NAME] START ";
printf "\n= = = = = = = = = = = = = = =\n$(_timestamp) \n" >> ${LOG_FILE};
/usr/local/bin/docker-compose exec -T php-fpm bash -c "make $TARGET_NAME" >> ${LOG_FILE} 2>&1;
printf "\n$(_timestamp) [stage-make][$STAGE_NAME::$TARGET_NAME] FINISHED\n";
